{"version":3,"sources":["../browserify/node_modules/browser-pack/_prelude.js","index","lib/index.js","lib/sanitize.js","lib/validate.js"],"names":["global","XP","require","XPEmitter","sanitize","validate","filterer","item","has","mapper","handle","assign","withdraw","types","freeze","keys","sanitizers","filter","map","validators","module","exports","XPSchema","Class","extends","initialize","options","self","this","call","fields","loose","useful","promise","value","data","resolver","waterfall","next","_assert","forOwn","field","key","reserved","merge","isDefined","prepare","isVoid","isFunction","val","isObject","set","static","get","_assertItem","enumerable","ValidationError","_assertData","window","sanitizeStep","step","isString","sanitizeValue","multi","index","type","exp","sanitizer","result","method","match","bool","validateStep","name","validateValue","validator","error","patterns","camelCase","camelCaseRegex","capitalize","capitalizeRegex","kebabCase","kebabCaseRegex","keyCase","keyCaseRegex","lowerCase","lowerCaseRegex","snakeCase","snakeCaseRegex","startCase","startCaseRegex","trim","trimRegex","upperCase","upperCaseRegex","uuid","uuidRegex","boolean","isBoolean","input","isInput","number","isFinite","object","recursive","string","exclusiveMaximum","max","exclusiveMinimum","min","immutable","current","isEquivalent","ImmutableError","xor","maximum","maxItems","attributes","isArray","length","maxLength","minimum","minItems","minLength","multipleOf","pattern","reg","isRegExp","toRegExp","test","InvalidError","required","isEmpty","RequiredError","uniqueItems","isUniq"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports=require(\"./lib\");","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\r\n\r\n/**\r\n * @license\r\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\r\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\r\n */\r\n(function (global) {\r\n    \"use strict\";\r\n\r\n    // Vars\r\n    var XP         = global.XP || require('expandjs'),\r\n        XPEmitter  = global.XPEmitter || require('xp-emitter'),\r\n\r\n        sanitize   = require('./sanitize'),\r\n        validate   = require('./validate'),\r\n\r\n        filterer   = function (item) { return XP.has(item, 'input') || XP.has(item, 'options'); },\r\n        mapper     = function (item, handle) { item = XP.assign({handle: handle}, item); XP.withdraw(item, 'method'); return item; },\r\n\r\n        types      = XP.freeze(XP.keys(validate.types)),\r\n        sanitizers = XP.freeze(XP.filter(XP.map(sanitize.sanitizers, mapper), filterer)),\r\n        validators = XP.freeze(XP.filter(XP.map(validate.validators, mapper), filterer));\r\n\r\n    /*********************************************************************/\r\n\r\n    /**\r\n     * This class is used to provide scheming functionalities.\r\n     *\r\n     * @class XPSchema\r\n     * @description This class is used to provide scheming functionalities\r\n     * @extends XPEmitter\r\n     */\r\n    module.exports = global.XPSchema = new XP.Class('XPSchema', {\r\n\r\n        // EXTENDS\r\n        extends: XPEmitter,\r\n\r\n        /*********************************************************************/\r\n\r\n        /**\r\n         * @constructs\r\n         * @param {Object} options\r\n         *   @param {Object} [options.fields]\r\n         *   @param {boolean} [options.loose = false]\r\n         *   @param {boolean} [options.useful = false]\r\n         */\r\n        initialize: function (options) {\r\n\r\n            // Vars\r\n            var self = this;\r\n\r\n            // Super\r\n            XPEmitter.call(self);\r\n\r\n            // Setting\r\n            self.options = options;\r\n            self.fields  = self.options.fields || {};\r\n            self.loose   = self.options.loose || false;\r\n            self.useful  = self.options.useful || false;\r\n        },\r\n\r\n        /*********************************************************************/\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @method filter\r\n         * @param {Object} data\r\n         * @param {Function} [resolver]\r\n         * @returns {Promise}\r\n         */\r\n        filter: {\r\n            promise: true,\r\n            value: function (data, resolver) {\r\n                var self = this;\r\n                XP.waterfall([\r\n                    function (next) { self._assert({data: data}, next); }, // asserting\r\n                    function (next) { next(null, XP.forOwn(self.fields, function (field, key) { if (field.reserved) { delete data[key]; } })); }, // filtering\r\n                    function (next) { next(null, data); } // resolving\r\n                ], resolver);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @method merge\r\n         * @param {Object} data\r\n         * @param {Object} [item]\r\n         * @param {boolean} [reserved = false]\r\n         * @param {Function} [resolver]\r\n         * @returns {Promise}\r\n         */\r\n        merge: {\r\n            promise: true,\r\n            value: function (data, item, reserved, resolver) {\r\n                var self = this;\r\n                XP.waterfall([\r\n                    function (next) { self._assert({data: data, item: item}, next); }, // asserting\r\n                    function (next) { next(null, XP.forOwn(item || {}, function (value, key) { if (!XP.isDefined(data[key]) && (!reserved || (self.fields[key] && self.fields[key].reserved))) { data[key] = item[key]; } })); }, // merging\r\n                    function (next) { next(null, data); } // resolving\r\n                ], resolver);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @method prepare\r\n         * @param {Object} data\r\n         * @param {Function} [resolver]\r\n         * @returns {Promise}\r\n         */\r\n        prepare: {\r\n            promise: true,\r\n            value: function (data, resolver) {\r\n                var self = this;\r\n                XP.waterfall([\r\n                    function (next) { self._assert({data: data}, next); }, // asserting\r\n                    function (next) { next(null, XP.forOwn(self.fields, function (field, key) { if (XP.isDefined(field.value) && XP.isVoid(data[key])) { data[key] = XP.isFunction(field.value) ? field.value() : field.value; } })); }, // preparing\r\n                    function (next) { next(null, data); } // resolving\r\n                ], resolver);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @method sanitize\r\n         * @param {Object} data\r\n         * @param {Function} [resolver]\r\n         * @returns {Promise}\r\n         */\r\n        sanitize: {\r\n            promise: true,\r\n            value: function (data, resolver) {\r\n                var self = this;\r\n                XP.waterfall([\r\n                    function (next) { self._assert({data: data}, next); }, // asserting\r\n                    function (next) { next(null, sanitize(data, self.fields, self.options)); }, // sanitizing\r\n                    function (next) { next(null, data); } // resolving\r\n                ], resolver);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @method validate\r\n         * @param {Object} data\r\n         * @param {Object} [item]\r\n         * @param {Function} [resolver]\r\n         * @returns {Promise}\r\n         */\r\n        validate: {\r\n            promise: true,\r\n            value: function (data, item, resolver) {\r\n                var self = this;\r\n                XP.waterfall([\r\n                    function (next) { self._assert({data: data, item: item}, next); }, // asserting\r\n                    function (next) { next(validate(data, self.fields, item), null); }, // validating\r\n                    function (next) { next(null, data); } // resolving\r\n                ], resolver);\r\n            }\r\n        },\r\n\r\n        /*********************************************************************/\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @property fields\r\n         * @type Object\r\n         */\r\n        fields: {\r\n            validate: function (val) { return !XP.isObject(val) && 'Object'; }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @property loose\r\n         * @type boolean\r\n         */\r\n        loose: {\r\n            set: function (val) { return !!val; }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @property sanitizers\r\n         * @type Object\r\n         * @readonly\r\n         * @static\r\n         */\r\n        sanitizers: {\r\n            'static': true,\r\n            get: function () { return sanitizers; }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @property types\r\n         * @type Array\r\n         * @readonly\r\n         * @static\r\n         */\r\n        types: {\r\n            'static': true,\r\n            get: function () { return types; }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @property useful\r\n         * @type boolean\r\n         */\r\n        useful: {\r\n            set: function (val) { return !!val; }\r\n        },\r\n\r\n        /**\r\n         * TODO DOC\r\n         *\r\n         * @property validators\r\n         * @type Object\r\n         * @readonly\r\n         * @static\r\n         */\r\n        validators: {\r\n            'static': true,\r\n            get: function () { return validators; }\r\n        },\r\n\r\n        /*********************************************************************/\r\n\r\n        // ASSERTS\r\n        _assertItem: {enumerable: false, value: function (val) { return !XP.isVoid(val) && !XP.isObject(val) && new XP.ValidationError('item', 'Object', 500); }},\r\n        _assertData: {enumerable: false, value: function (val) { return !XP.isObject(val) && new XP.ValidationError('data', 'Object', 400); }}\r\n    });\r\n\r\n}(typeof window !== \"undefined\" ? window : global));","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\r\n\r\n/**\r\n * @license\r\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\r\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\r\n */\r\n(function (global) {\r\n    \"use strict\";\r\n\r\n    // Vars\r\n    var exp = module.exports,\r\n        XP  = global.XP || require('expandjs');\r\n\r\n    /*********************************************************************/\r\n\r\n    /**\r\n     * Sanitize the data\r\n     *\r\n     * @param {Object} data\r\n     * @param {Object} fields\r\n     * @param {Object} [options]\r\n     * @returns {Object}\r\n     */\r\n    exp = module.exports = function (data, fields, options) {\r\n\r\n        // Restricting\r\n        XP.forOwn(data, function (val, key) {\r\n            if (!options.loose && !fields[key]) { delete data[key]; }\r\n        });\r\n\r\n        // Sanitizing\r\n        XP.forOwn(fields, function (field, key) {\r\n            data[key] = sanitizeStep(data[key], fields, options, key);\r\n            if (options.useful && XP.isVoid(data[key])) { delete data[key]; }\r\n        });\r\n\r\n        return data;\r\n    };\r\n\r\n    /**\r\n     * Sanitizes the step\r\n     *\r\n     * @param {*} step\r\n     * @param {Object} [fields]\r\n     * @param {Object} [options]\r\n     * @param {string} [key]\r\n     * @returns {*}\r\n     */\r\n    function sanitizeStep(step, fields, options, key) {\r\n\r\n        // Setting\r\n        step = XP.isDefined(step) ? step : null;\r\n\r\n        // Checking\r\n        if (!XP.isObject(fields[key]) && !XP.isString(fields[key], true)) { return step; }\r\n\r\n        // Sanitizing (step)\r\n        step = sanitizeValue(step, fields, options, key);\r\n\r\n        // Sanitizing (values)\r\n        if (fields[key].map || fields[key].multi) {\r\n            XP[fields[key].map ? 'forOwn' : 'forEach'](step, function (value, index) {\r\n                step[index] = sanitizeValue(step[index], fields, key, index);\r\n                if (XP.isObject(step[index]) && (fields[key].fields || fields[key].type === 'recursive')) {\r\n                    step[index] = exp(step[index], fields[key].fields || fields, XP.assign({}, options, {loose: fields[key].loose}));\r\n                }\r\n            });\r\n        } else if (XP.isObject(step) && (fields[key].fields || fields[key].type === 'recursive')) {\r\n            step = exp(step, fields[key].fields || fields, XP.assign({}, options, {loose: fields[key].loose}));\r\n        }\r\n\r\n        return step;\r\n    }\r\n\r\n    /**\r\n     * Sanitizes the value\r\n     *\r\n     * @param {*} value\r\n     * @param {Object} [fields]\r\n     * @param {Object} [options]\r\n     * @param {string} [key]\r\n     * @param {number | string} [index]\r\n     * @returns {*}\r\n     */\r\n    function sanitizeValue(value, fields, options, key, index) {\r\n\r\n        // Setting\r\n        value = XP.isDefined(value) ? value : null;\r\n\r\n        // Vars\r\n        var field     = (XP.isString(fields[key]) && {type: fields[key]}) || fields[key],\r\n            sanitizer = (XP.isVoid(index) && ((field.map && 'map') || (field.multi && 'multi'))) || 'type',\r\n            result    = exp.sanitizers[sanitizer].method(value, field[sanitizer]);\r\n\r\n        // Sanitizing\r\n        XP.forOwn(field, function (match, sanitizer) {\r\n            if (exp.sanitizers[sanitizer] && sanitizer !== 'map' && sanitizer !== 'multi' && sanitizer !== 'type') {\r\n                result = exp.sanitizers[sanitizer].method(result, match);\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /*********************************************************************/\r\n\r\n    /**\r\n     * The available sanitizers.\r\n     *\r\n     * @property sanitizers\r\n     * @type Object\r\n     */\r\n    exp.sanitizers = {\r\n\r\n        /**\r\n         * Returns map representation of value (based on bool)\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @returns {*}\r\n         */\r\n        map: {method: function (value, bool) {\r\n            return XP.isVoid(value) && bool ? {} : value;\r\n        }},\r\n\r\n        /**\r\n         * Returns array representation of value (based on bool)\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @returns {*}\r\n         */\r\n        multi: {method: function (value, bool) {\r\n            return XP.isVoid(value) && bool ? [] : value;\r\n        }},\r\n\r\n        /**\r\n         * Returns typed representation of value\r\n         *\r\n         * @param {*} value\r\n         * @param {string} type\r\n         * @returns {*}\r\n         */\r\n        type: {method: function (value, type) {\r\n            return XP.isVoid(value) && type === 'boolean' ? false : value;\r\n        }}\r\n    };\r\n\r\n}(typeof window !== \"undefined\" ? window : global));","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\r\n\r\n/**\r\n * @license\r\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\r\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\r\n */\r\n(function (global) {\r\n    \"use strict\";\r\n\r\n    // Vars\r\n    var exp = module.exports,\r\n        XP  = global.XP || require('expandjs');\r\n\r\n    /*********************************************************************/\r\n\r\n    /**\r\n     * Validates the data.\r\n     *\r\n     * @param {Object} data\r\n     * @param {Object} fields\r\n     * @param {Object} [item]\r\n     * @param {string} [name]\r\n     * @returns {Object}\r\n     */\r\n    exp = module.exports = function (data, fields, item, name) {\r\n\r\n        // Trying\r\n        try {\r\n\r\n            // Validating\r\n            XP.forOwn(fields, function (field, key) {\r\n                validateStep(data[key], fields, item, (name ? name + '.' : '') + key, key);\r\n            });\r\n\r\n            return null;\r\n        }\r\n\r\n        // Catching\r\n        catch (error) { return error; }\r\n    };\r\n\r\n    /**\r\n     * Validates the step.\r\n     *\r\n     * @param {*} step\r\n     * @param {Object} [fields]\r\n     * @param {Object} [item]\r\n     * @param {string} [name]\r\n     * @param {string} [key]\r\n     * @throws Error\r\n     */\r\n    function validateStep(step, fields, item, name, key) {\r\n\r\n        // Setting\r\n        step = XP.isDefined(step) ? step : null;\r\n\r\n        // Checking\r\n        if (!XP.isObject(fields[key]) && !XP.isString(fields[key], true)) { return; }\r\n\r\n        // Validating (step)\r\n        validateValue(step, fields, item, name, key);\r\n\r\n        // Validating (values)\r\n        if (fields[key].map || fields[key].multi) {\r\n            XP[fields[key].map ? 'forOwn' : 'forEach'](step, function (value, index) {\r\n                validateValue(value, fields, name + '[' + index + ']', key, index);\r\n                if (XP.isObject(value) && (fields[key].fields || fields[key].type === 'recursive')) {\r\n                    exp(value, fields[key].fields || fields, item, name + '[' + index + ']');\r\n                }\r\n            });\r\n        } else if (XP.isObject(step) && (fields[key].fields || fields[key].type === 'recursive')) {\r\n            exp(step, fields[key].fields || fields, item, name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the value.\r\n     *\r\n     * @param {*} value\r\n     * @param {Object} [fields]\r\n     * @param {Object} [item]\r\n     * @param {string} [name]\r\n     * @param {string} [key]\r\n     * @param {number | string} [index]\r\n     * @throws Error\r\n     */\r\n    function validateValue(value, fields, item, name, key, index) {\r\n\r\n        // Setting\r\n        value = XP.isDefined(value) ? value : null;\r\n\r\n        // Vars\r\n        var field     = (XP.isString(fields[key]) && {type: fields[key]}) || fields[key],\r\n            validator = (XP.isVoid(index) && ((field.map && 'map') || (field.multi && 'multi'))) || 'type',\r\n            error     = exp.validators[validator].method(value, field[validator], name);\r\n\r\n        // Throwing\r\n        if (error) { throw error; }\r\n\r\n        // Validating\r\n        XP.forOwn(field, function (match, validator) {\r\n            if (exp.validators[validator] && validator !== 'map' && validator !== 'multi' && validator !== 'type' && (validator !== 'immutable' || item)) {\r\n                if (error = exp.validators[validator].method(value, match, name, item && item[key])) { throw error; }\r\n            }\r\n        });\r\n    }\r\n\r\n    /*********************************************************************/\r\n\r\n    /**\r\n     * The available patterns.\r\n     *\r\n     * @property patterns\r\n     * @type Object\r\n     */\r\n    exp.patterns = {\r\n        camelCase: XP.camelCaseRegex,\r\n        capitalize: XP.capitalizeRegex,\r\n        kebabCase: XP.kebabCaseRegex,\r\n        keyCase: XP.keyCaseRegex,\r\n        lowerCase: XP.lowerCaseRegex,\r\n        snakeCase: XP.snakeCaseRegex,\r\n        startCase: XP.startCaseRegex,\r\n        trim: XP.trimRegex,\r\n        upperCase: XP.upperCaseRegex,\r\n        uuid: XP.uuidRegex\r\n    };\r\n\r\n    /**\r\n     * The available types.\r\n     *\r\n     * @property types\r\n     * @type Object\r\n     */\r\n    exp.types = {\r\n        boolean: XP.isBoolean,\r\n        input: XP.isInput,\r\n        number: XP.isFinite,\r\n        object: XP.isObject,\r\n        recursive: XP.isObject,\r\n        string: XP.isString\r\n    };\r\n\r\n    /**\r\n     * The available validators.\r\n     *\r\n     * @property validators\r\n     * @type Object\r\n     */\r\n    exp.validators = {\r\n\r\n        /**\r\n         * Returns error if value is gte than max.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        exclusiveMaximum: {input: 'number', type: 'number', method: function (value, max, name) {\r\n            return !XP.isFinite(value) || !XP.isFinite(max) ? false : (value >= max ? new XP.ValidationError(name || 'data', 'less than ' + max, 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is lte than min.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        exclusiveMinimum: {input: 'number', type: 'number', method: function (value, min, name) {\r\n            return !XP.isFinite(value) || !XP.isFinite(min) ? false : (value <= min ? new XP.ValidationError(name || 'data', 'greater than ' + min, 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is not equivalent to current (based on bool).\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @param {*} [current]\r\n         */\r\n        immutable: {input: 'checkbox', method: function (value, bool, name, current) {\r\n            return bool && !XP.isEquivalent(value, current) ? new XP.ImmutableError(name || 'data', 409) : null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is not an map (based on bool).\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        map: {input: 'checkbox', multi: true, method: function (value, bool, name) {\r\n            return XP.xor(bool, XP.isObject(value)) ? new XP.ValidationError(name || 'data', 'a map', 400) : null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is gt than max.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        maximum: {input: 'number', type: 'number', method: function (value, max, name) {\r\n            return !XP.isFinite(value) || !XP.isFinite(max) ? false : (value > max ? new XP.ValidationError(name || 'data', 'a maximum of ' + max, 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is gt than max.\r\n         *\r\n         * @param {Array} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        maxItems: {attributes: {min: 1}, input: 'number', multi: true, method: function (value, max, name) {\r\n            return !XP.isArray(value) || !XP.isFinite(max) || max < 1 ? false : (value.length > max ? new XP.ValidationError(name || 'data', 'a maximum of ' + max + ' items', 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is gt than max.\r\n         *\r\n         * @param {string} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        maxLength: {attributes: {min: 1}, input: 'number', type: 'string', method: function (value, max, name) {\r\n            return !XP.isString(value) || !XP.isFinite(max) || max < 1 ? false : (value.length > max ? new XP.ValidationError(name || 'data', 'a maximum of ' + max + ' chars', 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is lt than min.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error|null}\r\n         */\r\n        minimum: {input: 'number', type: 'number', method: function (value, min, name) {\r\n            return !XP.isFinite(value) || !XP.isFinite(min) ? false : (value < min ? new XP.ValidationError(name || 'data', 'a minimum of ' + min, 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is lt than min.\r\n         *\r\n         * @param {Array} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        minItems: {attributes: {min: 1}, input: 'number', multi: true, method: function (value, min, name) {\r\n            return !XP.isArray(value) || !XP.isFinite(min) ? false : (value.length < min ? new XP.ValidationError(name || 'data', 'a minimum of ' + min + ' items', 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is lt than min.\r\n         *\r\n         * @param {string} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error|null}\r\n         */\r\n        minLength: {attributes: {min: 1}, input: 'number', type: 'string', method: function (value, min, name) {\r\n            return !XP.isString(value) || !XP.isFinite(min) ? false : (value.length < min ? new XP.ValidationError(name || 'data', 'a minimum of ' + min + ' chars', 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is not array (based on bool).\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        multi: {input: 'checkbox', method: function (value, bool, name) {\r\n            return XP.xor(bool, XP.isArray(value)) ? new XP.ValidationError(name || 'data', 'multi', 400) : null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is not multiple of val.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} val\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        multipleOf: {input: 'number', type: 'number', method: function (value, val, name) {\r\n            return !XP.isFinite(value) || !XP.isFinite(val) ? false : (value % val !== 0 ? new XP.ValidationError(name || 'data', 'divisible by ' + val, 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value matches pattern.\r\n         *\r\n         * @param {string} value\r\n         * @param {string} pattern\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        pattern: {input: 'text', options: XP.keys(exp.patterns), type: 'string', method: function (value, pattern, name) {\r\n            var reg = XP.isString(value) && XP.isString(pattern, true) && (exp.patterns[pattern] || pattern);\r\n            if (XP.isString(reg) && XP.isRegExp(reg = XP.toRegExp(pattern))) { exp.patterns[pattern] = reg; }\r\n            return !reg ? false : (!reg.test(value) ? new XP.InvalidError(name || 'data', 400) : null);\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is empty (based on bool).\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        required: {input: 'checkbox', method: function (value, bool, name) {\r\n            return bool && XP.isEmpty(value) ? new XP.RequiredError(name || 'data', 400) : null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value type is not correct.\r\n         *\r\n         * @param {*} value\r\n         * @param {string} type\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error|null}\r\n         */\r\n        type: {attributes: {required: true}, options: XP.keys(exp.types), method: function (value, type, name) {\r\n            return exp.types[type] && !exp.types[type](value) && !XP.isVoid(value) ? new XP.ValidationError(name || 'data', type || 'any', 400) : null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value includes duplicates (based on bool).\r\n         *\r\n         * @param {Array} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error | null}\r\n         */\r\n        uniqueItems: {input: 'checkbox', multi: true, method: function (value, bool, name) {\r\n            return !XP.isArray(value) ? false : (bool && !XP.isUniq(value) ? new XP.ValidationError(name || 'data', 'should not have duplicates', 400) : null);\r\n        }}\r\n    };\r\n\r\n}(typeof window !== \"undefined\" ? window : global));"]}