{"version":3,"sources":["../../../../usr/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js","index","lib/index.js","lib/restrict.js","lib/sanitize.js","lib/validate.js"],"names":["global","XP","require","XPEmitter","restrict","sanitize","validate","filterer","item","hasOwnProperty","mapper","handle","assign","withdraw","types","freeze","keys","sanitizers","filter","map","validators","module","exports","XPSchema","Class","extends","initialize","options","self","this","call","fields","strict","useful","promise","value","data","resolver","waterfall","next","_assert","forOwn","field","key","reserved","merge","reservedOnly","isDefined","prepare","isVoid","isFunction","val","isObject","static","get","set","_assertData","enumerable","ValidationError","_assertItem","window","restrictStep","step","multi","index","type","exp","sanitizeStep","isString","sanitizeValue","sanitizer","result","method","match","validateStep","name","validateValue","validator","error","patterns","camelCase","camelCaseRegex","capitalize","capitalizeRegex","kebabCase","kebabCaseRegex","keyCase","keyCaseRegex","lowerCase","lowerCaseRegex","snakeCase","snakeCaseRegex","startCase","startCaseRegex","trim","trimRegex","upperCase","upperCaseRegex","uuid","uuidRegex","boolean","isBoolean","input","isInput","number","isFinite","object","recursive","string","exclusiveMaximum","max","exclusiveMinimum","min","immutable","bool","current","isEquivalent","ImmutableError","maximum","maxItems","attributes","isArray","length","maxLength","minimum","minItems","minLength","multipleOf","pattern","reg","isRegExp","toRegExp","test","InvalidError","required","isEmpty","RequiredError","uniqueItems","isUniq"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports=require(\"./lib\");","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\n\n/**\n * @license\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\n */\n(function (global) {\n    \"use strict\";\n\n    // Vars\n    var XP         = global.XP || require('expandjs'),\n        XPEmitter  = global.XPEmitter || require('xp-emitter'),\n\n        restrict   = require('./restrict'),\n        sanitize   = require('./sanitize'),\n        validate   = require('./validate'),\n\n        filterer   = function (item) { return item.hasOwnProperty('input') || item.hasOwnProperty('options'); },\n        mapper     = function (item, handle) { item = XP.assign({handle: handle}, item); XP.withdraw(item, 'method'); return item; },\n\n        types      = XP.freeze(XP.keys(validate.types)),\n        sanitizers = XP.freeze(XP.filter(XP.map(sanitize.sanitizers, mapper), filterer)),\n        validators = XP.freeze(XP.filter(XP.map(validate.validators, mapper), filterer));\n\n    /*********************************************************************/\n\n    /**\n     * A class used to provide scheming functionalities.\n     *\n     * @class XPSchema\n     * @description A class used to provide scheming functionalities\n     * @extends XPEmitter\n     */\n    module.exports = global.XPSchema = new XP.Class('XPSchema', {\n\n        // EXTENDS\n        extends: XPEmitter,\n\n        /*********************************************************************/\n\n        /**\n         * @constructs\n         * @param {Object} options\n         *   @param {Object} [options.fields]\n         *   @param {boolean} [options.strict = false]\n         *   @param {boolean} [options.useful = false]\n         */\n        initialize: function (options) {\n\n            // Vars\n            var self = this;\n\n            // Super\n            XPEmitter.call(self);\n\n            // Setting\n            self.options = options;\n            self.fields  = self.options.fields || {};\n            self.strict  = self.options.strict || false;\n            self.useful  = self.options.useful || false;\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @method filter\n         * @param {Object} data\n         * @param {Function} [resolver]\n         * @returns {Promise}\n         */\n        filter: {\n            promise: true,\n            value: function (data, resolver) {\n                var self = this;\n                XP.waterfall([\n                    function (next) { self._assert({data: data}, next); }, // asserting\n                    function (next) { next(null, XP.forOwn(self.fields, function (field, key) { if (field.reserved) { delete data[key]; } })); }, // filtering\n                    function (next) { next(null, data); } // resolving\n                ], resolver);\n            }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @method merge\n         * @param {Object} data\n         * @param {Object} [item]\n         * @param {boolean} [reservedOnly = false]\n         * @param {Function} [resolver]\n         * @returns {Promise}\n         */\n        merge: {\n            promise: true,\n            value: function (data, item, reservedOnly, resolver) {\n                var self = this;\n                XP.waterfall([\n                    function (next) { self._assert({data: data, item: item}, next); }, // asserting\n                    function (next) { next(null, XP.forOwn(item || {}, function (value, key) { if (!XP.isDefined(data[key]) && (!reservedOnly || (self.fields[key] && self.fields[key].reserved))) { data[key] = item[key]; } })); }, // merging\n                    function (next) { next(null, data); } // resolving\n                ], resolver);\n            }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @method prepare\n         * @param {Object} data\n         * @param {Function} [resolver]\n         * @returns {Promise}\n         */\n        prepare: {\n            promise: true,\n            value: function (data, resolver) {\n                var self = this;\n                XP.waterfall([\n                    function (next) { self._assert({data: data}, next); }, // asserting\n                    function (next) { next(null, XP.forOwn(self.fields, function (field, key) { if (XP.isDefined(field.value) && XP.isVoid(data[key])) { data[key] = XP.isFunction(field.value) ? field.value() : field.value; } })); }, // preparing\n                    function (next) { next(null, data); } // resolving\n                ], resolver);\n            }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @method restrict\n         * @param {Object} data\n         * @param {Function} [resolver]\n         * @returns {Promise}\n         */\n        restrict: {\n            promise: true,\n            value: function (data, resolver) {\n                var self = this;\n                XP.waterfall([\n                    function (next) { self._assert({data: data}, next); }, // asserting\n                    function (next) { next(null, restrict(data, self.fields, self.options)); }, // restricting\n                    function (next) { next(null, data); } // resolving\n                ], resolver);\n            }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @method sanitize\n         * @param {Object} data\n         * @param {Function} [resolver]\n         * @returns {Promise}\n         */\n        sanitize: {\n            promise: true,\n            value: function (data, resolver) {\n                var self = this;\n                XP.waterfall([\n                    function (next) { self._assert({data: data}, next); }, // asserting\n                    function (next) { next(null, sanitize(data, self.fields)); }, // sanitizing\n                    function (next) { next(null, data); } // resolving\n                ], resolver);\n            }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @method validate\n         * @param {Object} data\n         * @param {Object} [item]\n         * @param {Function} [resolver]\n         * @returns {Promise}\n         */\n        validate: {\n            promise: true,\n            value: function (data, item, resolver) {\n                var self = this;\n                XP.waterfall([\n                    function (next) { self._assert({data: data, item: item}, next); }, // asserting\n                    function (next) { next(validate(data, self.fields, item), null); }, // validating\n                    function (next) { next(null, data); } // resolving\n                ], resolver);\n            }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property fields\n         * @type Object\n         */\n        fields: {\n            validate: function (val) { return !XP.isObject(val) && 'Object'; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property sanitizers\n         * @type Object\n         * @readonly\n         * @static\n         */\n        sanitizers: {\n            'static': true,\n            get: function () { return sanitizers; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property strict\n         * @type boolean\n         * @default false\n         */\n        strict: {\n            set: function (val) { return !!val; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property types\n         * @type Array\n         * @readonly\n         * @static\n         */\n        types: {\n            'static': true,\n            get: function () { return types; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property useful\n         * @type boolean\n         * @default false\n         */\n        useful: {\n            set: function (val) { return !!val; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property validators\n         * @type Object\n         * @readonly\n         * @static\n         */\n        validators: {\n            'static': true,\n            get: function () { return validators; }\n        },\n\n        /*********************************************************************/\n\n        // ASSERTS\n        _assertData: {enumerable: false, value: function (val) { return !XP.isObject(val) && new XP.ValidationError('data', 'Object', 400); }},\n        _assertItem: {enumerable: false, value: function (val) { return !XP.isVoid(val) && !XP.isObject(val) && new XP.ValidationError('item', 'Object', 500); }}\n    });\n\n}(typeof window !== \"undefined\" ? window : global));\n","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\n\n/**\n * @license\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\n */\n(function (global) {\n    \"use strict\";\n\n    // Vars\n    var exp = module.exports,\n        XP  = global.XP || require('expandjs');\n\n    /*********************************************************************/\n\n    /**\n     * Restricts the data\n     *\n     * @param {Object} data\n     * @param {Object} fields\n     * @param {Object} [options]\n     * @returns {Object}\n     */\n    exp = module.exports = function (data, fields, options) {\n\n        // Restricting\n        XP.forOwn(data, function (val, key) {\n            if (options.strict && !fields[key]) { delete data[key]; return; }\n            if (options.useful && XP.isVoid(data[key])) { delete data[key]; return; }\n            data[key] = restrictStep(data[key], fields, options, key);\n        });\n\n        return data;\n    };\n\n    /**\n     * Restricts the step\n     *\n     * @param {*} step\n     * @param {Object} [fields]\n     * @param {Object} [options]\n     * @param {string} [key]\n     * @returns {*}\n     */\n    function restrictStep(step, fields, options, key) {\n\n        // Restricting (values)\n        if (fields[key].multi === 'list' || fields[key].multi === 'map') {\n            XP[fields[key].multi === 'list' ? 'forEach' : 'forOwn'](step, function (value, index) {\n                if (XP.isObject(step[index]) && (fields[key].fields || fields[key].type === 'recursive')) {\n                    step[index] = exp(step[index], fields[key].fields || fields, options);\n                }\n            });\n        } else if (XP.isObject(step) && (fields[key].fields || fields[key].type === 'recursive')) {\n            step = exp(step, fields[key].fields || fields, options);\n        }\n\n        return step;\n    }\n\n}(typeof window !== \"undefined\" ? window : global));\n","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\n\n/**\n * @license\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\n */\n(function (global) {\n    \"use strict\";\n\n    // Vars\n    var exp = module.exports,\n        XP  = global.XP || require('expandjs');\n\n    /*********************************************************************/\n\n    /**\n     * Sanitize the data\n     *\n     * @param {Object} data\n     * @param {Object} fields\n     * @returns {Object}\n     */\n    exp = module.exports = function (data, fields) {\n\n        // Sanitizing\n        XP.forOwn(fields, function (field, key) {\n            data[key] = sanitizeStep(data[key], fields, key);\n        });\n\n        return data;\n    };\n\n    /**\n     * Sanitizes the step\n     *\n     * @param {*} step\n     * @param {Object} [fields]\n     * @param {string} [key]\n     * @returns {*}\n     */\n    function sanitizeStep(step, fields, key) {\n\n        // Setting\n        step = XP.isDefined(step) ? step : null;\n\n        // Checking\n        if (!XP.isObject(fields[key]) && !XP.isString(fields[key], true)) { return step; }\n\n        // Sanitizing (step)\n        step = sanitizeValue(step, fields, key);\n\n        // Sanitizing (values)\n        if (fields[key].multi === 'list' || fields[key].multi === 'map') {\n            XP[fields[key].multi === 'list' ? 'forEach' : 'forOwn'](step, function (value, index) {\n                step[index] = sanitizeValue(step[index], fields, key, index);\n                if (XP.isObject(step[index]) && (fields[key].fields || fields[key].type === 'recursive')) {\n                    step[index] = exp(step[index], fields[key].fields || fields);\n                }\n            });\n        } else if (XP.isObject(step) && (fields[key].fields || fields[key].type === 'recursive')) {\n            step = exp(step, fields[key].fields || fields);\n        }\n\n        return step;\n    }\n\n    /**\n     * Sanitizes the value\n     *\n     * @param {*} value\n     * @param {Object} [fields]\n     * @param {string} [key]\n     * @param {number | string} [index]\n     * @returns {*}\n     */\n    function sanitizeValue(value, fields, key, index) {\n\n        // Setting\n        value = XP.isDefined(value) ? value : null;\n\n        // Vars\n        var field     = XP.isString(fields[key]) ? {type: fields[key]} : fields[key],\n            sanitizer = XP.isVoid(index) && (field.multi === 'list' || field.multi === 'map') ? 'multi' : 'type',\n            result    = exp.sanitizers[sanitizer].method(value, field[sanitizer]);\n\n        // Sanitizing\n        XP.forOwn(field, function (match, sanitizer) {\n            if (exp.sanitizers[sanitizer] && sanitizer !== 'multi' && sanitizer !== 'type') {\n                result = exp.sanitizers[sanitizer].method(result, match);\n            }\n        });\n\n        return result;\n    }\n\n    /*********************************************************************/\n\n    /**\n     * The available sanitizers.\n     *\n     * @property sanitizers\n     * @type Object\n     */\n    exp.sanitizers = {\n\n        /**\n         * Returns multi representation of value (based on bool)\n         *\n         * @param {*} value\n         * @param {string} multi\n         * @returns {*}\n         */\n        multi: {method: function (value, type) {\n            if (type === 'list' && XP.isVoid(value)) { return []; }\n            if (type === 'map' && XP.isVoid(value)) { return {}; }\n            return value;\n        }},\n\n        /**\n         * Returns typed representation of value\n         *\n         * @param {*} value\n         * @param {string} type\n         * @returns {*}\n         */\n        type: {method: function (value, type) {\n            if (type === 'boolean' && XP.isVoid(value)) { return false; }\n            return value;\n        }}\n    };\n\n}(typeof window !== \"undefined\" ? window : global));\n","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\r\n\r\n/**\r\n * @license\r\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\r\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\r\n */\r\n(function (global) {\r\n    \"use strict\";\r\n\r\n    // Vars\r\n    var exp = module.exports,\r\n        XP  = global.XP || require('expandjs');\r\n\r\n    /*********************************************************************/\r\n\r\n    /**\r\n     * Validates the data.\r\n     *\r\n     * @param {Object} data\r\n     * @param {Object} fields\r\n     * @param {Object} [item]\r\n     * @param {string} [name]\r\n     * @returns {Object}\r\n     */\r\n    exp = module.exports = function (data, fields, item, name) {\r\n\r\n        // Trying\r\n        try {\r\n\r\n            // Validating\r\n            XP.forOwn(fields, function (field, key) {\r\n                validateStep(data[key], fields, item, (name ? name + '.' : '') + key, key);\r\n            });\r\n\r\n            return null;\r\n        }\r\n\r\n        // Catching\r\n        catch (error) { return error; }\r\n    };\r\n\r\n    /**\r\n     * Validates the step.\r\n     *\r\n     * @param {*} step\r\n     * @param {Object} [fields]\r\n     * @param {Object} [item]\r\n     * @param {string} [name]\r\n     * @param {string} [key]\r\n     * @throws Error\r\n     */\r\n    function validateStep(step, fields, item, name, key) {\r\n\r\n        // Setting\r\n        step = XP.isDefined(step) ? step : null;\r\n\r\n        // Checking\r\n        if (!XP.isObject(fields[key]) && !XP.isString(fields[key], true)) { return; }\r\n\r\n        // Validating (step)\r\n        validateValue(step, fields, item, name, key);\r\n\r\n        // Validating (values)\r\n        if (fields[key].multi === 'list' || fields[key].multi === 'map') {\r\n            XP[fields[key].multi === 'list' ? 'forEach' : 'forOwn'](step, function (value, index) {\r\n                validateValue(value, fields, item, name + '[' + index + ']', key, index);\r\n                if (XP.isObject(value) && (fields[key].fields || fields[key].type === 'recursive')) {\r\n                    exp(value, fields[key].fields || fields, item, name + '[' + index + ']');\r\n                }\r\n            });\r\n        } else if (XP.isObject(step) && (fields[key].fields || fields[key].type === 'recursive')) {\r\n            exp(step, fields[key].fields || fields, item, name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the value.\r\n     *\r\n     * @param {*} value\r\n     * @param {Object} [fields]\r\n     * @param {Object} [item]\r\n     * @param {string} [name]\r\n     * @param {string} [key]\r\n     * @param {number | string} [index]\r\n     * @throws Error\r\n     */\r\n    function validateValue(value, fields, item, name, key, index) {\r\n\r\n        // Setting\r\n        value = XP.isDefined(value) ? value : null;\r\n\r\n        // Vars\r\n        var field     = XP.isString(fields[key]) ? {type: fields[key]} : fields[key],\r\n            validator = XP.isVoid(index) && (field.multi === 'list' || field.multi === 'map') ? 'multi' : 'type',\r\n            error     = exp.validators[validator].method(value, field[validator], name);\r\n\r\n        // Throwing\r\n        if (error) { throw error; }\r\n\r\n        // Validating\r\n        XP.forOwn(field, function (match, validator) {\r\n            if (exp.validators[validator] && validator !== 'multi' && validator !== 'type' && (validator !== 'immutable' || item)) {\r\n                if (error = exp.validators[validator].method(value, match, name, item && item[key])) { throw error; }\r\n            }\r\n        });\r\n    }\r\n\r\n    /*********************************************************************/\r\n\r\n    /**\r\n     * The available patterns.\r\n     *\r\n     * @property patterns\r\n     * @type Object\r\n     */\r\n    exp.patterns = {\r\n        camelCase: XP.camelCaseRegex,\r\n        capitalize: XP.capitalizeRegex,\r\n        kebabCase: XP.kebabCaseRegex,\r\n        keyCase: XP.keyCaseRegex,\r\n        lowerCase: XP.lowerCaseRegex,\r\n        snakeCase: XP.snakeCaseRegex,\r\n        startCase: XP.startCaseRegex,\r\n        trim: XP.trimRegex,\r\n        upperCase: XP.upperCaseRegex,\r\n        uuid: XP.uuidRegex\r\n    };\r\n\r\n    /**\r\n     * The available types.\r\n     *\r\n     * @property types\r\n     * @type Object\r\n     */\r\n    exp.types = {\r\n        boolean: XP.isBoolean,\r\n        input: XP.isInput,\r\n        number: XP.isFinite,\r\n        object: XP.isObject,\r\n        recursive: XP.isObject,\r\n        string: XP.isString\r\n    };\r\n\r\n    /**\r\n     * The available validators.\r\n     *\r\n     * @property validators\r\n     * @type Object\r\n     */\r\n    exp.validators = {\r\n\r\n        /**\r\n         * Returns error if value is gte than max.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        exclusiveMaximum: {input: 'number', type: 'number', method: function (value, max, name) {\r\n            if (!XP.isFinite(value) || !XP.isFinite(max)) { return false; }\r\n            if (value >= max) { return new XP.ValidationError(name || 'data', 'less than ' + max, 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is lte than min.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        exclusiveMinimum: {input: 'number', type: 'number', method: function (value, min, name) {\r\n            if (!XP.isFinite(value) || !XP.isFinite(min)) { return false; }\r\n            if (value <= min) { return new XP.ValidationError(name || 'data', 'greater than ' + min, 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is not equivalent to current (based on bool).\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @param {*} [current]\r\n         */\r\n        immutable: {input: 'checkbox', method: function (value, bool, name, current) {\r\n            if (bool && !XP.isEquivalent(value, current)) { return new XP.ImmutableError(name || 'data', 409); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is gt than max.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        maximum: {input: 'number', type: 'number', method: function (value, max, name) {\r\n            if (!XP.isFinite(value) || !XP.isFinite(max)) { return false; }\r\n            if (value > max) { return new XP.ValidationError(name || 'data', 'a maximum of ' + max, 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is gt than max.\r\n         *\r\n         * @param {Array} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        maxItems: {attributes: {min: 1}, input: 'number', multi: true, method: function (value, max, name) {\r\n            if (!XP.isArray(value) || !XP.isFinite(max) || max < 1) { return false; }\r\n            if (value.length > max) { return new XP.ValidationError(name || 'data', 'a maximum of ' + max + ' items', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is gt than max.\r\n         *\r\n         * @param {string} value\r\n         * @param {number} max\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        maxLength: {attributes: {min: 1}, input: 'number', type: 'string', method: function (value, max, name) {\r\n            if (!XP.isString(value) || !XP.isFinite(max) || max < 1) { return false; }\r\n            if (value.length > max) { return new XP.ValidationError(name || 'data', 'a maximum of ' + max + ' chars', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is lt than min.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error|null}\r\n         */\r\n        minimum: {input: 'number', type: 'number', method: function (value, min, name) {\r\n            if (!XP.isFinite(value) || !XP.isFinite(min)) { return false; }\r\n            if (value < min) { return new XP.ValidationError(name || 'data', 'a minimum of ' + min, 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is lt than min.\r\n         *\r\n         * @param {Array} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        minItems: {attributes: {min: 1}, input: 'number', multi: true, method: function (value, min, name) {\r\n            if (!XP.isArray(value) || !XP.isFinite(min)) { return false; }\r\n            if (value.length < min) { return new XP.ValidationError(name || 'data', 'a minimum of ' + min + ' items', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value length is lt than min.\r\n         *\r\n         * @param {string} value\r\n         * @param {number} min\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error|null}\r\n         */\r\n        minLength: {attributes: {min: 1}, input: 'number', type: 'string', method: function (value, min, name) {\r\n            if (!XP.isString(value) || !XP.isFinite(min)) { return false; }\r\n            if (value.length < min) { return new XP.ValidationError(name || 'data', 'a minimum of ' + min + ' chars', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is not array (based on bool).\r\n         *\r\n         * @param {*} value\r\n         * @param {string} type\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        multi: {options: ['none', 'list', 'map'], method: function (value, type, name) {\r\n            if (type === 'list' && !XP.isArray(value)) { return new XP.ValidationError(name || 'data', 'a list', 400); }\r\n            if (type === 'map' && !XP.isObject(value)) { return new XP.ValidationError(name || 'data', 'a map', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is not multiple of val.\r\n         *\r\n         * @param {number} value\r\n         * @param {number} val\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        multipleOf: {input: 'number', type: 'number', method: function (value, val, name) {\r\n            if (!XP.isFinite(value) || !XP.isFinite(val)) { return false; }\r\n            if (value % val !== 0) { return new XP.ValidationError(name || 'data', 'divisible by ' + val, 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value matches pattern.\r\n         *\r\n         * @param {string} value\r\n         * @param {string} pattern\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        pattern: {input: 'text', options: XP.keys(exp.patterns), type: 'string', method: function (value, pattern, name) {\r\n            var reg = XP.isString(value) && XP.isString(pattern, true) && (exp.patterns[pattern] || pattern);\r\n            if (XP.isString(reg) && XP.isRegExp(reg = XP.toRegExp(pattern))) { exp.patterns[pattern] = reg; }\r\n            if (reg && !reg.test(value)) { return new XP.InvalidError(name || 'data', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value is empty (based on bool).\r\n         *\r\n         * @param {*} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        required: {input: 'checkbox', method: function (value, bool, name) {\r\n            if (bool && XP.isEmpty(value)) { return new XP.RequiredError(name || 'data', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value type is not correct.\r\n         *\r\n         * @param {*} value\r\n         * @param {string} type\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        type: {attributes: {required: true}, options: XP.keys(exp.types), method: function (value, type, name) {\r\n            if (exp.types[type] && !exp.types[type](value) && !XP.isVoid(value)) { return new XP.ValidationError(name || 'data', type || 'any', 400); }\r\n            return null;\r\n        }},\r\n\r\n        /**\r\n         * Returns error if value includes duplicates (based on bool).\r\n         *\r\n         * @param {Array} value\r\n         * @param {boolean} bool\r\n         * @param {string} [name]\r\n         * @returns {boolean | Error}\r\n         */\r\n        uniqueItems: {input: 'checkbox', multi: true, method: function (value, bool, name) {\r\n            if (!XP.isArray(value)) { return false; }\r\n            if (bool && !XP.isUniq(value)) { return new XP.ValidationError(name || 'data', 'should not have duplicates', 400); }\r\n            return null;\r\n        }}\r\n    };\r\n\r\n}(typeof window !== \"undefined\" ? window : global));"]}